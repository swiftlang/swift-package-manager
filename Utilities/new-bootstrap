#!/usr/bin/env python

"""
 This source file is part of the Swift.org open source project

 Copyright (c) 2014 - 2019 Apple Inc. and the Swift project authors
 Licensed under Apache License v2.0 with Runtime Library Exception

 See http://swift.org/LICENSE.txt for license information
 See http://swift.org/CONTRIBUTORS.txt for Swift project authors

 -------------------------------------------------------------------------
"""

from __future__ import print_function

import argparse
from distutils import dir_util
from distutils import file_util
import errno
import os
import platform
import shutil
import subprocess
import sys

if platform.system() == 'Darwin':
    g_shared_lib_ext = ".dylib"
else:
    g_shared_lib_ext = ".so"

def main():
    parser = argparse.ArgumentParser(description="""
        This script will build a bootstrapped copy of the Swift Package Manager, and optionally perform extra
        actions like installing the result (with 'install') to a location ('--prefix').
        """)
    subparsers = parser.add_subparsers(dest='command')

    # clean
    parser_clean = subparsers.add_parser("clean", help="cleans build artifacts")
    parser_clean.set_defaults(func=clean)
    add_global_args(parser_clean)

    # build-runtimes
    parser_build_runtimes = subparsers.add_parser("build-runtimes", help="builds the runtime libraries")
    parser_build_runtimes.set_defaults(func=build_runtimes)
    add_build_args(parser_build_runtimes)

    # build
    parser_build = subparsers.add_parser("build", help="builds SwiftPM and runtime libraries")
    parser_build.set_defaults(func=build)
    add_build_args(parser_build)

    # test
    parser_test = subparsers.add_parser("test", help="builds and tests SwiftPM")
    parser_test.set_defaults(func=test)
    add_test_args(parser_test)

    # install
    parser_install = subparsers.add_parser("install", help="builds and installs SwiftPM and runtime libraries")
    parser_install.set_defaults(func=install)
    add_build_args(parser_install)

    args = parser.parse_args()
    args.func = args.func or build
    args.func(args)

# -----------------------------------------------------------
# Argument parsing
# -----------------------------------------------------------

def add_global_args(parser):
    """Configures the parser with the arguments necessary for all actions."""
    parser.add_argument(
        "--build-dir",
        help="path where products will be built [%(default)s]",
        default=".build",
        metavar="PATH")
    parser.add_argument(
        "-v", "--verbose",
        action="store_true",
        help="whether to print verbose output")

def add_build_args(parser):
    """Configures the parser with the arguments necessary for build-related actions."""
    add_global_args(parser)
    parser.add_argument(
        "--swiftc-path",
        help="path to the swift compiler",
        metavar="PATH")
    parser.add_argument(
        "--clang-path",
        help="path to the clang compiler",
        metavar="PATH")
    parser.add_argument(
        '--cmake-path',
        metavar='PATH',
        help='path to the cmake binary to use for building')
    parser.add_argument(
        '--ninja-path',
        metavar='PATH',
        help='path to the ninja binary to use for building with CMake')
    parser.add_argument(
        "--llbuild-build-dir",
        help="path to llbuild build directory")
    parser.add_argument(
        "--llbuild-link-framework",
        action="store_true",
        help="whether to link to the llbuild framework")
    parser.add_argument(
        "--release",
        action="store_true",
        help="enables building SwiftPM in release mode")
    parser.add_argument(
        "--libswiftpm-install-dir",
        metavar='PATH',
        help="where to install libSwiftPM")
    parser.add_argument(
        "--prefix",
        dest="install_prefixes",
        nargs='*',
        help="paths (relative to the project root) where to install build products [%(default)s]",
        default=["/tmp/swiftpm"],
        metavar="PATHS")

def add_test_args(parser):
    """Configures the parser with the arguments necessary for the test action."""
    add_build_args(parser)
    parser.add_argument(
        "--parallel",
        action="store_true",
        help="whether to run tests in parallel",
        default=True)
    parser.add_argument(
        "--filter",
        action="append",
        help="filter to apply on which tests to run",
        default=[])

def parse_global_args(args):
    """Parses and cleans arguments necessary for all actions."""
    args.build_dir = os.path.abspath(args.build_dir)
    args.project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    args.source_root = os.path.join(args.project_root, "Sources")

    if platform.system() == 'Darwin':
        args.sysroot = call_output(["xcrun", "--sdk", "macosx", "--show-sdk-path"], verbose=args.verbose)
    else:
        args.sysroot = None

def parse_build_args(args):
    """Parses and cleans arguments necessary for build-related actions."""
    parse_global_args(args)

    if args.llbuild_build_dir:
        args.llbuild_build_dir = os.path.abspath(args.llbuild_build_dir)

    args.swiftc_path = get_swiftc_path(args)
    args.clang_path = get_clang_path(args)
    args.cmake_path = get_cmake_path(args)
    args.ninja_path = get_ninja_path(args)
    args.target_dir = os.path.join(args.build_dir, get_build_target(args))
    args.bootstrap_dir = os.path.join(args.target_dir, "bootstrap")
    args.conf = 'release' if args.release else 'debug'
    args.bin_dir = os.path.join(args.target_dir, args.conf)

def parse_test_args(args):
    """Parses and cleans arguments necessary for the test action."""
    parse_build_args(args)

def get_swiftc_path(args):
    """Returns the path to the Swift compiler."""
    if args.swiftc_path:
        swiftc_path = os.path.abspath(args.swiftc_path)
    elif os.getenv("SWIFT_EXEC"):
        swiftc_path = os.path.realpath(os.getenv("SWIFT_EXEC"))
    elif platform.system() == 'Darwin':
        swiftc_path = call_output(
            ["xcrun", "--find", "swiftc"],
            stderr=subprocess.PIPE,
            verbose=args.verbose
        )
    else:
        swiftc_path = call_output(["which", "swiftc"], verbose=args.verbose)

    if os.path.basename(swiftc_path) == 'swift':
        swiftc_path = swiftc_path + 'c'

    return swiftc_path

def get_clang_path(args):
    """Returns the path to the Clang compiler."""
    if args.clang_path:
        return os.path.abspath(args.clang_path)
    elif platform.system() == 'Darwin':
        return call_output(
            ["xcrun", "--find", "clang"],
            stderr=subprocess.PIPE,
            verbose=args.verbose
        )
    else:
        return call_output(["which", "clang"], verbose=args.verbose)

def get_cmake_path(args):
    """Returns the path to CMake."""
    if args.cmake_path:
        return os.path.abspath(args.cmake_path)
    elif platform.system() == 'Darwin':
        return call_output(
            ["xcrun", "--find", "cmake"],
            stderr=subprocess.PIPE,
            verbose=args.verbose
        )
    else:
        return call_output(["which", "cmake"], verbose=args.verbose)

def get_ninja_path(args):
    """Returns the path to Ninja."""
    if args.ninja_path:
        return os.path.abspath(args.ninja_path)
    elif platform.system() == 'Darwin':
        return call_output(
            ["xcrun", "--find", "ninja"],
            stderr=subprocess.PIPE,
            verbose=args.verbose
        )
    else:
        return call_output(["which", "ninja"], verbose=args.verbose)

def get_build_target(args):
    """Returns the target-triple of the current machine."""
    if platform.system() == 'Darwin':
        return "x86_64-apple-macosx"
    elif platform.system() == 'Linux':
        if platform.machine() == 'x86_64':
            return "x86_64-unknown-linux-gnu"
        elif platform.machine() == "i686":
            return "i686-unknown-linux"
        elif platform.machine() == 's390x':
            return "s390x-unknown-linux"
        elif platform.machine() == 'ppc64le':
            return 'powerpc64le-unknown-linux'
        elif platform.machine().startswith("armv7"):
            return 'armv7-unknown-linux-gnueabihf'
        elif platform.machine() == 'aarch64':
            return 'aarch64-unknown-linux'
        else:
            raise SystemExit("ERROR: unsupported machine:", platform.machine())
    elif platform.system() == 'Windows':
        return 'x86_64-unknown-windows-msvc'
    else:
        raise SystemExit("ERROR: unsupported system:", platform.system(), platform.machine())

# -----------------------------------------------------------
# Actions
# -----------------------------------------------------------

def clean(args):
    """Cleans the build artifacts."""
    note("Cleaning")
    parse_global_args(args)

    call(["rm", "-rf", args.build_dir], verbose=args.verbose)

def build_runtimes(args):
    """Builds the PackageDescription runtime libraries."""
    note("Building runtimes")
    parse_build_args(args)

    source_dir = os.path.join(args.project_root, "Utilities/BuildRuntimesOnly")
    build_dir = os.path.join(args.target_dir, "runtimes_only")
    build_with_cmake(args, [], source_dir, build_dir)

def build(args):
    """Builds SwiftPM using a two-step process: first using CMake, then with itself."""
    parse_build_args(args)

    # Build llbuild if its build path is not passed in.
    if not args.llbuild_build_dir:
        build_llbuild(args)

    build_swiftpm_with_cmake(args)
    build_swiftpm_with_swiftpm(args)

def test(args):
    """Builds SwiftPM, then tests itself."""
    build(args)

    note("Testing")
    parse_test_args(args)
    cmd = [os.path.join(args.bin_dir, "swift-test")]
    if args.parallel:
        cmd.append("--parallel")
    for arg in args.filter:
        cmd.extend(["--filter", arg])
    call_swiftpm(args, cmd)

def install(args):
    """Builds SwiftPM, then installs its build products."""
    build(args)

    # Install swiftpm content in all of the passed prefixes.
    for prefix in args.install_prefixes:
        install_swiftpm(prefix, args)

    # Install libSwiftPM if an install directory was provided.
    if args.libswiftpm_install_dir:
        dest = args.libswiftpm_install_dir

        # FIXME: Don't hardcode the suffix.
        install_binary(args, "libSwiftPM.dylib", dest)

        libswiftpm_modules = [
            "TSCLibc", "TSCBasic",
            "TSCUtility", "SourceControl",
            "SPMLLBuild", "LLBuildManifest",
            "PackageModel", "PackageLoading",
            "PackageGraph", "Build",
            "Xcodeproj", "Workspace"
        ]

        # Install the swiftmodule and swiftdoc files.
        for module in libswiftpm_modules:
            install_binary(args, module + ".swiftmodule", dest)
            install_binary(args, module + ".swiftdoc", dest)

        # Install the C headers.
        tscclibc_include_dir = os.path.join(args.source_root, "TSCclibc/include")
        tscclibc_include_dir_dest = os.path.join(dest, "TSCclibc")
        dir_util.copy_tree(tscclibc_include_dir, tscclibc_include_dir_dest)

def install_swiftpm(prefix, args):
    # Install swiftpm binaries.
    for binary in ["swift-build", "swift-test", "swift-run", "swift-package"]:
        dest = os.path.join(prefix, "bin")
        install_binary(args, binary, dest)

    if platform.system() == 'Darwin':
        dest = os.path.join(prefix, "libexec", "swift", "pm")
        install_binary(args, "swiftpm-xctest-helper", dest)

    # Install PackageDescription runtime libraries.
    runtime_lib_dest = os.path.join(prefix, "lib", "swift", "pm")
    runtime_lib_src = os.path.join(args.bootstrap_dir, "pm")

    for runtime in ["4", "4_2"]:
        files_to_install = ["libPackageDescription" + g_shared_lib_ext]
        if platform.system() == 'Darwin':
            files_to_install.append("PackageDescription.swiftinterface")
        else:
            files_to_install.append("PackageDescription.swiftmodule")
            files_to_install.append("PackageDescription.swiftdoc")

        for file in files_to_install:
            src = os.path.join(runtime_lib_src, runtime, file)
            dest = os.path.join(runtime_lib_dest, runtime, file)
            mkdir_p(os.path.dirname(dest))

            note("Installing %s to %s" % (src, dest))

            file_util.copy_file(src, dest, update=1)


def install_binary(args, binary, dest_dir):
    src = os.path.join(args.bin_dir, binary)
    dest = os.path.join(dest_dir, binary)

    note("Installing %s to %s" % (src, dest))

    mkdir_p(os.path.dirname(dest))
    file_util.copy_file(src, dest, update=1)

# -----------------------------------------------------------
# Build functions
# -----------------------------------------------------------

def build_with_cmake(args, cmake_args, source_path, build_dir):
    """Runs CMake if needed, then builds with Ninja."""
    cache_path = os.path.join(build_dir, "CMakeCache.txt")
    if not os.path.isfile(cache_path):
        swift_flags = ""
        if args.sysroot:
            swift_flags = "-sdk %s" % args.sysroot

        cmd = [
            args.cmake_path, "-G", "Ninja",
            "-DCMAKE_MAKE_PROGRAM=%s" % args.ninja_path,
            "-DCMAKE_BUILD_TYPE:=Debug",
            "-DCMAKE_Swift_FLAGS=" + swift_flags,
            "-DCMAKE_Swift_COMPILER:=%s" % (args.swiftc_path),
        ] + cmake_args + [source_path]

        if args.verbose:
            print(' '.join(cmd))

        mkdir_p(build_dir)
        call(cmd, cwd=build_dir, verbose=True)

    # Build.
    ninja_cmd = [args.ninja_path]

    if args.verbose:
        ninja_cmd.append("-v")

    call(ninja_cmd, cwd=build_dir, verbose=args.verbose)

def build_llbuild(args):
    """Builds LLBuild using CMake."""
    note("Building llbuild")

    # Set where we are going to build llbuild for future steps to find it
    args.llbuild_build_dir = os.path.join(args.target_dir, "llbuild")

    api_dir = os.path.join(args.llbuild_build_dir, ".cmake/api/v1/query")
    mkdir_p(api_dir)
    call(["touch", "codemodel-v2"], cwd=api_dir, verbose=args.verbose)

    flags = [
        "-DCMAKE_C_COMPILER:=clang",
        "-DCMAKE_CXX_COMPILER:=clang++",
        "-DLLBUILD_SUPPORT_BINDINGS:=Swift",
    ]

    if args.sysroot:
        flags.append("-DSQLite3_INCLUDE_DIR=%s/usr/include" % args.sysroot)

    llbuild_source_dir = get_llbuild_source_path(args)
    build_with_cmake(args, flags, llbuild_source_dir, args.llbuild_build_dir)

def build_swiftpm_with_cmake(args):
    """Builds SwiftPM using CMake."""
    note("Building SwiftPM (with CMake)")

    cmake_flags = [
        get_llbuild_cmake_arg(args),
        "-DUSE_VENDORED_TSC=ON",
    ]

    if platform.system() == 'Darwin':
        cmake_flags.append("-DCMAKE_C_FLAGS=-target x86_64-apple-macosx10.10")
        cmake_flags.append("-DCMAKE_OSX_DEPLOYMENT_TARGET=10.10")

    build_with_cmake(args, cmake_flags, args.project_root, args.bootstrap_dir)

def build_swiftpm_with_swiftpm(args):
    """Builds SwiftPM using the version of SwiftPM built with CMake."""
    note("Building SwiftPM (with swift-build)")

    call_swiftpm(args, [
        "SWIFT_EXEC=" + args.swiftc_path,
        "SWIFTPM_PD_LIBS=" + os.path.join(args.bootstrap_dir, "pm"),

        os.path.join(args.bootstrap_dir, "bin/swift-build"),
        # Always build tests in stage2.
        "--build-tests",
        "--disable-sandbox",
    ])

    # Setup symlinks that'll allow using swiftpm from the build directory.
    symlink_force(args.swiftc_path, os.path.join(args.target_dir, args.conf, "swiftc"))
    symlink_force(args.swiftc_path, os.path.join(args.target_dir, args.conf, "swift"))

    lib_dir = os.path.join(args.target_dir, "lib", "swift")

    # Remove old cruft.
    if os.path.isdir(lib_dir):
        shutil.rmtree(lib_dir)

    mkdir_p(lib_dir)

    symlink_force(os.path.join(args.bootstrap_dir, "pm"), os.path.join(lib_dir, "pm"))

def call_swiftpm(args, cmd):
    """Calls a SwiftPM binary with the necessary environment variables and flags."""
    full_cmd = get_swiftpm_env_cmd(args) + cmd + get_swiftpm_flags(args)
    call(full_cmd, cwd=args.project_root, verbose=True)

# -----------------------------------------------------------
# Build-related helper functions
# -----------------------------------------------------------

def get_llbuild_cmake_arg(args):
    """Returns the CMake argument to the LLBuild framework/binary to use for bulding SwiftPM."""
    if args.llbuild_link_framework:
        return "-DCMAKE_FIND_FRAMEWORK_EXTRA_LOCATIONS=%s" % args.llbuild_build_dir
    else:
        llbuild_dir = os.path.join(args.llbuild_build_dir, "cmake/modules")
        return "-DLLBuild_DIR=" + llbuild_dir

def get_llbuild_source_path(args):
    """Returns the path to the LLBuild source folder."""
    llbuild_path = os.path.join(args.project_root, "..", "llbuild")
    if os.path.exists(llbuild_path):
        return llbuild_path
    note("clone llbuild next to swiftpm directory; see development docs: https://github.com/apple/swift-package-manager/blob/master/Documentation/Development.md#using-trunk-snapshot")
    error("unable to find llbuild source directory at %s" % llbuild_path)

def get_swiftpm_env_cmd(args):
    """Returns the environment variable command to run SwiftPM binaries."""
    env_cmd = ["env"]

    if args.sysroot:
        env_cmd.append("SDKROOT=%s" % args.sysroot)

    if args.llbuild_link_framework:
        env_cmd.append("DYLD_FRAMEWORK_PATH=%s" % args.llbuild_build_dir)
        # FIXME: We always need to pass this.
        env_cmd.append("SWIFTPM_BOOTSTRAP=1")
    else:
        env_cmd.append("SWIFTCI_USE_LOCAL_DEPS=1")

    libs_joined = ":".join([
        os.path.join(args.bootstrap_dir, "lib"),
        os.path.join(args.llbuild_build_dir, "lib"),
    ])

    if platform.system() == 'Darwin':
        env_cmd.append("DYLD_LIBRARY_PATH=%s" % libs_joined)
    else:
        env_cmd.append("LD_LIBRARY_PATH=%s" % libs_joined)

    return env_cmd

def get_swiftpm_flags(args):
    """Returns the flags to run SwiftPM binaries."""
    build_flags = [
        # No need for indexing while building.
        "--disable-index-store",
        "--build-path", args.build_dir
    ]

    if args.release:
        build_flags.extend([
            "-Xswiftc", "-enable-testing",
            "--configuration", "release"
        ])

    if args.verbose:
        build_flags.append("--verbose")

    if args.llbuild_link_framework:
        build_flags.extend([
            "-Xswiftc", "-F" + args.llbuild_build_dir,
            "-Xlinker", "-F" + args.llbuild_build_dir,
            "-Xlinker", "-rpath",
            "-Xlinker", "@executable_path/../../../../../SharedFrameworks",
        ])

    # Add a rpath to find core swift libraries on linux. We don't need a rpath
    # for Darwin because the Swift libraries are present in the OS.
    if platform.system() == 'Linux':
        build_flags.extend(["-Xlinker", "-rpath=$ORIGIN/../lib/swift/linux"])

    return build_flags

# -----------------------------------------------------------
# Shell helper functions
# -----------------------------------------------------------

def note(message):
    print("--- %s: note: %s" % (os.path.basename(sys.argv[0]), message))
    sys.stdout.flush()

def error(message):
    print("--- %s: error: %s" % (os.path.basename(sys.argv[0]), message))
    sys.stdout.flush()
    raise SystemExit(1)

def symlink_force(source, destination):
    try:
        os.symlink(source, destination)
    except OSError as e:
        if e.errno == errno.EEXIST:
            os.remove(destination)
            os.symlink(source, destination)

def mkdir_p(path):
    """Create the given directory, if it does not exist."""
    try:
        os.makedirs(path)
    except OSError as e:
        # Ignore EEXIST, which may occur during a race condition.
        if e.errno != errno.EEXIST:
            raise

def call(cmd, cwd=None, verbose=False):
    """Calls a subprocess."""
    if verbose:
        print(' '.join(cmd))
    try:
        subprocess.check_call(cmd, cwd=cwd)
    except Exception as e:
        if not verbose:
            print(' '.join(cmd))
        error(str(e))

def call_output(cmd, cwd=None, stderr=False, verbose=False):
    """Calls a subprocess for its return data."""
    if verbose:
        print(' '.join(cmd))
    try:
        return subprocess.check_output(cmd, cwd=cwd, stderr=stderr, universal_newlines=True).strip()
    except Exception as e:
        if not verbose:
            print(' '.join(cmd))
        error(str(e))

if __name__ == '__main__':
    main()
