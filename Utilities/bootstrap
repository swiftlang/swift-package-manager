#!/usr/bin/env python

"""
 This source file is part of the Swift.org open source project

 Copyright 2015 - 2016 Apple Inc. and the Swift project authors
 Licensed under Apache License v2.0 with Runtime Library Exception

 See http://swift.org/LICENSE.txt for license information
 See http://swift.org/CONTRIBUTORS.txt for Swift project authors

 -------------------------------------------------------------------------
 This script is used to bootstrap the Swift package manager build.

 It does so by writing out a build task file which can be used to build a
 stage1 package manager. That package manager is then expected to be able
 to build itself to produce the production tools.

 Note that currently this script is also responsible for building the package
 manager in such a way that it can be installed along with the Swift package. In
 particular, it knows how to build the runtime PackageDescription library
 correctly and install it.

"""

from __future__ import print_function

try:
    from cStringIO import StringIO
except ImportError:
    from io import StringIO
import argparse
import codecs
import errno
import json
import os
import pipes
import platform
import re
import shlex
import shutil
import subprocess
import sys
import tempfile

def note(message):
    print("--- %s: note: %s" % (os.path.basename(sys.argv[0]), message))
    sys.stdout.flush()


def error(message):
    print("--- %s: error: %s" % (os.path.basename(sys.argv[0]), message))
    sys.stdout.flush()
    raise SystemExit(1)

def symlink_force(target, link_name):
    if os.path.isdir(link_name):
        link_name = os.path.join(link_name, os.path.basename(target))
    try:
        os.symlink(target, link_name)
    except OSError as e:
        if e.errno == errno.EEXIST:
            os.remove(link_name)
            os.symlink(target, link_name)
        else:
            raise e

def mkdir_p(path):
    """
    mkdir_p(path)

    Create the given directory, if it does not exist.
    """

    try:
        os.makedirs(path)
    except OSError as e:
        # Ignore EEXIST, which may occur during a race condition.
        if e.errno != errno.EEXIST:
            raise


# FIXME: Consider eliminating this once the build task format supports node
# hashing.
def write_file_if_changed(path, data):
    """
    write_file_if_changed(path, data)

    Write the given data to the path, only updating the file if the contents are
    different than the current ones.
    """

    try:
        with open(path) as f:
            old_data = f.read()
    except:
        old_data = None
    if old_data == data:
        return

    with open(path, "w") as f:
        f.write(data)

###

g_num_cpus = os.sysconf("SC_NPROCESSORS_ONLN")
g_default_sysroot = None
if platform.system() == 'Darwin':
    g_platform_path = subprocess.check_output(
        ["xcrun", "--sdk", "macosx", "--show-sdk-platform-path"],
        universal_newlines=True).strip()
    g_default_sysroot = subprocess.check_output(
        ["xcrun", "--sdk", "macosx", "--show-sdk-path"],
        universal_newlines=True).strip()

if platform.system() == 'Linux':
    g_shared_lib_ext = ".so"
else:
    g_shared_lib_ext = ".dylib"

class Target(object):
    @property
    def virtual_node(self):
        return "<target-%s>" % (self.name)

    @property
    def linked_virtual_node(self):
        return "<link-%s>" % (self.name)

    def __init__(self, name, dependencies=[], swiftflags=[], extra_libs=[],
                 subpath=None):
        self.name = name
        self.module_name = self.name.replace("-", "_")
        self.dependencies = list(dependencies)
        self.swiftflags = list(swiftflags)
        self.extra_libs = list(extra_libs)

        # Discover the source files, and whether or not this is a library.
        self.is_library = True
        self.is_swift = False
        # FIXME: Currently only C libraries are supported in bootstrap script.
        self.is_c = False

        self.sources = []
        self.module_root_dir = os.path.join(g_source_root, subpath or self.name)

        for (dirpath, dirnames, filenames) in os.walk(self.module_root_dir):
            for name in filenames:
                path = os.path.join(dirpath, name)
                _, ext = os.path.splitext(name)
                if ext == '.swift':
                    self.is_swift = True
                    if name == 'main.swift':
                        self.is_library = False
                    self.sources.append(path)
                if ext == '.c':
                    self.is_c = True
                    self.sources.append(path)

        if self.is_swift and self.is_c:
            error("Target %s contains mixed C and Swift sources which is unsupported." % (self.name))

        self.sources.sort()

    def write_compile_commands(self, args, target_build_dir,
                                     module_dir, include_dir, output, objects,
                                     link_input_nodes, predecessor_node):
        if self.is_swift:
            self.write_swift_compile_commands(args, target_build_dir, module_dir,
                                              include_dir, output, objects, link_input_nodes,
                                              predecessor_node)
        elif self.is_c:
            self.write_c_compile_commands(args, target_build_dir, module_dir,
                                              include_dir, output, objects, link_input_nodes,
                                              predecessor_node)


    def write_swift_compile_commands(self, args, target_build_dir,
                                     module_dir, include_dir, output, objects,
                                     link_input_nodes, predecessor_node):
        # Compute the derived paths.
        module_path = os.path.join(module_dir, "%s.swiftmodule" % (self.name,))

        # Create the per-file entries.
        swift_objects = []
        for path in self.sources:
            filename = os.path.basename(path)
            base_path = os.path.join(
                target_build_dir, os.path.splitext(filename)[0])
            object_path = base_path + ".o"
            swift_objects.append(object_path)
            objects.append(object_path)

        # Form the command to build all the swift files.
        #
        # FIXME: The -j doesn't belong here, and should move into the
        # 'swift' tool.
        other_args = ['-Onone', '-j%d' % g_num_cpus] + self.swiftflags
        if platform.system() == 'Darwin':
            other_args.extend(["-target", "x86_64-apple-macosx10.10"])
        if args.sysroot:
            other_args.extend(["-sdk", args.sysroot])
        compile_swift_node = '<compile-swift-%s>' % (self.name,)
        link_input_nodes.append(compile_swift_node)

        if args.libdispatch_source_dir:
            other_args.extend(["-Xcc", "-fblocks"])
        
        print("  %s:" % json.dumps(compile_swift_node), file=output)
        print("    tool: swift-compiler", file=output)
        print("    executable: %s" % json.dumps(args.swiftc_path), file=output)
        # FIXME: We shouldn't even need to specify the sources here once we have
        # discovered dependencies support.
        print("    inputs: %s" % json.dumps(
            [predecessor_node] + self.sources), file=output)
        print("    outputs: %s" % json.dumps(
            [compile_swift_node, module_path] + swift_objects), file=output)
        print("    module-name: %s" % json.dumps(self.module_name), file=output)
        print("    module-output-path: %s" % json.dumps(module_path),
              file=output)
        print("    sources: %s" % json.dumps(self.sources), file=output)
        print("    objects: %s" % json.dumps(swift_objects), file=output)
        import_paths = [module_dir, include_dir]

        # For C interpolation add import path to where modulemap is located.
        for dependency in self.dependencies:
            dep_target = target_map[dependency]
            if dep_target.is_c:
                import_paths.append(os.path.join(dep_target.module_root_dir, "include"))

        if args.foundation_path:
            import_paths.append(args.foundation_path)
            import_paths.append(os.path.join(args.foundation_path,
                                             "usr/lib/swift/CoreFoundation"))
            import_paths.append(os.path.join(args.foundation_path,
                                             "usr/lib/swift"))
        if args.libdispatch_build_dir:
            import_paths.append(os.path.join(args.libdispatch_build_dir,
                                             "src"))
            import_paths.append(os.path.join(args.libdispatch_build_dir,
                                             "src", "swift"))
        if args.libdispatch_source_dir:
            import_paths.append(args.libdispatch_source_dir)
        if args.xctest_path:
            import_paths.append(args.xctest_path)
        print("    import-paths: %s" % json.dumps(import_paths), file=output)
        print("    other-args: %s" % json.dumps(other_args),
              file=output)
        print("    temps-path: %s" % json.dumps(target_build_dir), file=output)
        print("    is-library: %s" % json.dumps(
            str(bool(self.is_library)).lower()), file=output)
        print(file=output)

    def write_c_compile_commands(self, args, target_build_dir,
                                     module_dir, include_dir, output, objects,
                                     link_input_nodes, predecessor_node):

        common_args = ["-fobjc-arc", "-fmodule-name=%s" % self.module_name]
        if platform.system() == 'Darwin':
            common_args.extend(["-arch", "x86_64", "-mmacosx-version-min=10.10"])

        if args.sysroot:
            common_args.extend(["-isysroot", args.sysroot])

        common_args.extend(["-g", "-O0", "-MD", "-MT", "dependencies", "-MF"])

        for source in self.sources:
            filename = os.path.basename(source)
            base_path = os.path.join(
                target_build_dir, os.path.splitext(filename)[0])
            object_path = base_path + ".o"
            deps_path = base_path + ".d"
            objects.append(object_path)

            link_input_nodes.append(object_path)

            args = ["clang"]
            args.extend(common_args)
            args.extend([deps_path, "-c", source,"-o", object_path])

            print("  %s:" % json.dumps(object_path), file=output)
            print("    tool: clang", file=output)
            print("    description: Compile %s" % filename, file=output)
            print("    inputs: %s" % json.dumps([source]), file=output)
            print("    outputs: %s" % json.dumps([object_path]), file=output)
            print("    args: %s" % json.dumps(args), file=output)
            print("    deps: %s" % json.dumps(deps_path), file=output)
            print(file=output)


# currently only returns the targets parsed from the manifest
def parse_manifest():
    # we have a *very* strict format for our manifest to make parsing more
    # robust
    pattern = re.compile(
        r'Target\(.*?name: "(.*?)",\n *dependencies: (\[.*?\])\)',
        re.DOTALL | re.MULTILINE)
    manifest_data = codecs.open(os.path.join(g_project_root,
                                "Package.swift"), encoding='utf-8',
                                errors='strict').read()

    def convert(match):
        name = match.group(1)
        deps = eval(match.group(2))
        return Target(name, deps)
    targets = list(map(convert, pattern.finditer(manifest_data)))

    # Remove the targets which should be ignored in stage 1.
    targets = [target for target in targets
               if target.name not in g_ignored_targets and
                  not target.name.endswith("Tests")]

    # substitute strings for Target objects
    for target in targets:
        def convert(targetName):
            try:
                return next(a for a in targets if a.name == targetName)
            except StopIteration:
                # this target is not explicit in the manifest: it is an
                # implicit target
                b = Target(targetName)
                targets.append(b)
                return b
        target.dependencies = list(map(convert, target.dependencies))

    # fill dependency graph and set dependencies back to strings
    def convert(target):
        myset = set()

        def recurse(root):
            deps = []
            for dep in root.dependencies:
                if dep.name not in myset:
                    myset.add(dep.name)
                    deps += recurse(dep) + [dep.name]
            return deps
        # `reversed` because Linux link order must be reverse-topological
        return Target(target.name, reversed(recurse(target)))
    return list(map(convert, targets))

# Hard-coded target definition.
g_project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
g_source_root = os.path.join(g_project_root, "Sources")
g_ignored_targets = ["swiftpm-xctest-helper", "TestSupport"]
targets = parse_manifest()
target_map = dict((t.name, t) for t in targets)


# Create a quoted C string literal from an arbitrary string.
def make_c_string_literal(str):
    return "\"" + str.replace("\\", "\\\\").replace("\"", "\\\"") + "\""

# Create a quoted XML string literal from an arbitrary string.
def make_xml_string_literal(str):
    return "\"" + str.replace("&", "&amp;").replace("\"", "&quot;") + "\""


# Write out a header containing version information, and a module map for it.
def write_bootstrap_version_info(include_path, vendor_name, build_identifier):
    # Construct the header and write it out if it's changed.
    output = StringIO()
    vendor_name_literal = make_c_string_literal(vendor_name)
    build_identifier_literal = make_c_string_literal(build_identifier)
    contents = """
static inline const char* VendorNameString() {
    return %(vendor_name_literal)s;
}
static inline const char* BuildIdentifierString() {
    return %(build_identifier_literal)s;
}
""" % locals()
    write_file_if_changed(os.path.join(include_path, "VersionInfo.h"), contents)
    
    # Also construct the module map and write it out if it's changed.
    contents = """\
module VersionInfo [extern_c] {
    header \"VersionInfo.h\"
}
"""
    write_file_if_changed(os.path.join(include_path, "module.map"), contents)


def create_bootstrap_files(sandbox_path, args):
    # Write out the build file.
    output = StringIO()

    # Write out the task file header.
    print("client:", file=output)
    print("  name: swift-build", file=output)
    print(file=output)

    # Write out the tools section.
    #
    # FIXME: Not yet defined.
    print("tools: {}", file=output)
    print(file=output)

    # Compute the list of active targets.
    active_targets = targets

    # Write out the targets list.
    #
    # We support 'all' (build all targets) and an individual name for each
    # target.
    #
    # FIXME: Need support for default target.
    print("targets:", file=output)
    print("  \"\": %s" % (json.dumps(
        [target.virtual_node for target in active_targets]),), file=output)
    print("  all: %s" % (json.dumps(
        [target.virtual_node for target in active_targets]),), file=output)
    for target in active_targets:
        print("  %s: %s" % (
            target.name, json.dumps([target.virtual_node])), file=output)
    print(file=output)

    # Create the shared include dir.
    inc_dir = os.path.join(sandbox_path, "inc")
    mkdir_p(inc_dir)
    
    # Create the shared lib dir.
    lib_dir = os.path.join(sandbox_path, "lib")
    mkdir_p(lib_dir)

    # Create the shared bin dir.
    bin_dir = os.path.join(sandbox_path, "bin")
    mkdir_p(bin_dir)

    # Create the shared module dir.
    module_dir = os.path.join(sandbox_path, "modules")
    mkdir_p(module_dir)

    print("commands:", file=output)
    for target in targets:
        print("  # Target Commands: %r" % (target.name,), file=output)
        target_build_dir = os.path.join(sandbox_path, target.name + ".build")
        mkdir_p(target_build_dir)

        predecessor_node = "<entry-%s>" % (target.name,)
        objects = []
        link_input_nodes = [predecessor_node]

        # Write out the predecessor node used to order w.r.t. other targets.
        print("  %s:" % json.dumps(predecessor_node), file=output)
        print("    tool: phony", file=output)
        print("    inputs: %s" % json.dumps(
            [target_map[name].virtual_node for name in target.dependencies]),
            file=output)
        print("    outputs: %s" % json.dumps([predecessor_node]), file=output)
        print(file=output)

        # Write out the target build commands (we just name the command and node
        # the same).

        # Write the compile commands, if used.
        if target.sources:
            target.write_compile_commands(
                args, target_build_dir, module_dir, inc_dir, output, objects,
                link_input_nodes, predecessor_node)


        # llbuild tool to use for this command.
        tool = "shell"

        # Form the command line to link.
        linked_libraries = []
        if target.is_swift and target.is_library:
            tool = "archive"
            link_output_path = os.path.join(lib_dir, "%s.a" % (target.name,))
            link_command = [] # Archive tool auto infers objects from inputs.
        elif target.is_c and target.is_library:
            # We have to use shared library for interpolation between Swift and C so we can't use static library for C Targets.
            link_output_path = os.path.join(lib_dir, target.name + g_shared_lib_ext)
            link_command = ['clang', ' '.join(pipes.quote(o) for o in objects), '-shared',
                            '-o', pipes.quote(link_output_path)]
        elif target.is_c and not target.is_library:
            error("Executable C target not supported by bootstrap yet")
        elif target.is_swift and not target.is_library:
            link_output_path = os.path.join(bin_dir, target.name)

            link_command = [args.swiftc_path,
                            '-o', pipes.quote(link_output_path)]
            if args.sysroot:
                link_command.extend(["-sdk", args.sysroot])
            if platform.system() == 'Darwin':
                link_command.extend(["-target", "x86_64-apple-macosx10.10"])
            link_command.append(' '.join(pipes.quote(o) for o in objects))
            for dependency in target.dependencies:
                dep_target = target_map[dependency]
                if dep_target.is_swift:
                    dependency_lib_path = os.path.join(lib_dir, "%s.a" % dependency)
                else:
                    dependency_lib_path = os.path.join(lib_dir, dependency + g_shared_lib_ext)
                link_command.append(pipes.quote(dependency_lib_path))
                linked_libraries.append(dependency_lib_path)
            if platform.system() == 'Darwin':
                link_command.extend(["-Xlinker", "-all_load"])
            for lib in target.extra_libs:
                link_command.extend(["-Xlinker", "-l%s" % (lib,)])
            if platform.system() == 'Linux':
                link_command.extend(
                    ["-Xlinker", "-rpath=$ORIGIN/../lib/swift/linux"])
            if args.foundation_path:
                link_command.extend(["-L", args.foundation_path])
            if args.libdispatch_build_dir:
                link_command.extend(["-L", os.path.join(args.libdispatch_build_dir, "src", ".libs")])

        # Write out the link command.
        if target.is_library:
            description = "Link %s" % target.name
        else:
            description = "Link %s" % link_output_path
        writeTool(
            tool,
            target.linked_virtual_node,
            description,
            link_input_nodes + objects + linked_libraries,
            [target.linked_virtual_node, link_output_path],
            link_command,
            output)

        # Write the top-level target group command.
        print("  %s:" % json.dumps(target.virtual_node), file=output)
        print("    tool: phony", file=output)
        print("    inputs: %s" % json.dumps(
            [target.linked_virtual_node]), file=output)
        print("    outputs: %s" % json.dumps([target.virtual_node]),
              file=output)
        print(file=output)

    # Write the output file.
    write_file_if_changed(os.path.join(sandbox_path, "build.swift-build"),
                          output.getvalue())
    
    # Write out the version info header and module map file, if appropriate.
    if args.vendor_name or args.build_identifier:
        if not args.vendor_name or not args.build_identifier:
            error("--build-identifier is required with --vendor-name")
        write_bootstrap_version_info(inc_dir, args.vendor_name,
                                     args.build_identifier)

# Write out the tool into output buffer.
# Supported tools: shell and archive. args is ignored for archive tool.
def writeTool(tool, node, description, inputs, outputs, args, output):
    print("  %s:" % json.dumps(node), file=output)
    print("    tool: %s" % tool, file=output)
    print("    description: %s" % description, file=output)
    print("    inputs: %s" % json.dumps(inputs), file=output)
    print("    outputs: %s" % json.dumps(outputs), file=output)
    if tool == "shell":
        print("    args: %s" % json.dumps(args), file=output)
    print(file=output)


def process_runtime_libraries(build_path, args, bootstrap=False):
    if bootstrap:
        module_input_path = os.path.join(
            build_path, "modules", "PackageDescription.swiftmodule")
        input_lib_path = os.path.join(
            build_path, "lib", "PackageDescription.a")
    else:
        module_input_path = os.path.join(
            build_path, "debug", "PackageDescription.swiftmodule")
        input_lib_path = os.path.join(
            build_path, "debug", "libPackageDescription.a")

    lib_path = os.path.join(build_path, "lib", "swift", "pm")
    mkdir_p(lib_path)
    runtime_module_path = os.path.join(
        lib_path, "PackageDescription.swiftmodule")
    cmd = ["cp", module_input_path, runtime_module_path]
    subprocess.check_call(cmd)
    if platform.system() == 'Darwin':
        runtime_lib_path = os.path.join(lib_path, "libPackageDescription.dylib")
        cmd = [args.swiftc_path, "-Xlinker", "-dylib", "-o",
               runtime_lib_path,
               "-Xlinker", "-all_load",
               input_lib_path,
               "-target", "x86_64-apple-macosx10.10"]
    else:
        # Derive the command line to use by querying to swiftc
        # driver. Unfortunately we cannot use it directly due to the inability
        # to use an -X... style arg to pass arguments to the Clang driver, which
        # it calls before calling the linker.

        # This is the command we would like to use.
        #
        # We include an RPATH entry so that the Swift libraries can be found
        # relative to where it will be installed (in 'lib/swift/pm/...').
        runtime_lib_path = os.path.join(lib_path, "libPackageDescription.so")
        cmd = [args.swiftc_path, "-Xlinker", "-shared", "-o", runtime_lib_path,
               "-Xlinker", "--whole-archive",
               "-Xlinker", input_lib_path,
               "-Xlinker", "--no-whole-archive", "-lswiftGlibc",
               "-Xlinker", "-rpath=$ORIGIN/../linux"]

        # We need to pass one swift file here to bypass the "no input files"
        # error.
        tf = tempfile.NamedTemporaryFile(suffix=".swift")
        cmds = subprocess.check_output(
            cmd + [tf.name, "-###"],
            universal_newlines=True).strip().split("\n")

        # Get the link command 'swiftc' used.
        link_cmd = shlex.split(cmds[-1])

        # Unqoute any quoted characters.
        link_cmd = [arg.replace("\\", "") for arg in link_cmd]

        # Drop any .o files, and the -Xlinker which precedes '-shared'.
        try:
            idx = link_cmd.index("-shared")
        except:
            idx = -1
        if idx == -1 or link_cmd[idx - 1] != "-Xlinker":
            raise SystemExit("unable to understand 'swiftc' driver commands")
        del link_cmd[idx - 1]
        cmd = [arg for arg in link_cmd
               if arg.endswith(("swift_begin.o", "swift_end.o")) or
               (not arg.endswith((".o", ".autolink")))]
    subprocess.check_call(cmd)
    return (runtime_module_path, runtime_lib_path)


def get_swift_build_tool_path():
    # Search for a 'swift-build-tool' to use.

    # First, look in $(BUILT_PRODUCTS_DIR) in case we are being built from Xcode
    # along with the llbuild project.
    built_products_dir = os.environ.get("BUILT_PRODUCTS_DIR")
    if built_products_dir:
        sbt_path = os.path.join(built_products_dir, "swift-build-tool")
        if os.path.exists(sbt_path):
            return sbt_path

    SWIFT_EXEC = os.getenv("SWIFT_EXEC")
    if SWIFT_EXEC:
        maybe_path = os.path.join(SWIFT_EXEC, "../swift-build-tool")
        if os.path.exists(maybe_path):
            return maybe_path

    # If that failed, on Darwin use xcrun to search for the tool.
    if platform.system() == 'Darwin':
        try:
            sbt_path = subprocess.check_output(
                ["xcrun", "--find", "swift-build-tool"],
                stderr=subprocess.PIPE, universal_newlines=True).strip()
            if os.path.exists(sbt_path):
                return sbt_path
        except subprocess.CalledProcessError:
            pass
    else:
        # Otherwise, search for it in PATH.
        try:
            return subprocess.check_output(["which", "swift-build-tool"],
                                           universal_newlines=True).strip()
        except:
            pass

    # If all else failed, report an error.
    error("unable to find 'swift-build-tool' tool for bootstrap build")


def get_swiftc_path():
    try:
        if os.getenv("SWIFT_EXEC"):
            return os.path.realpath(os.getenv("SWIFT_EXEC"))
        elif platform.system() == 'Darwin':
            return subprocess.check_output(["xcrun", "--find", "swiftc"],
                stderr=subprocess.PIPE, universal_newlines=True).strip()
        else:
            return subprocess.check_output(["which", "swiftc"],
            universal_newlines=True).strip()
    except:
        error("unable to find 'swiftc' tool for bootstrap build")


def main():
    parser = argparse.ArgumentParser(
        usage="%(prog)s [options] [clean|all|test|install]",
        description="This script will build a bootstrapped copy of the Swift "
                    "Package Manager, and optionally perform extra actions "
                    "like installing the result (with 'install') to a "
                    "location ('--prefix').")
    parser.add_argument("build_actions",
                        help="Extra actions to perform. Can be any number of "
                             "the following: [clean, all, test, install]",
                        nargs="*", default=["all"])
    parser.add_argument("--swiftc", dest="swiftc_path",
                        help="path to the swift compiler [%(default)s]",
                        metavar="PATH")
    parser.add_argument("--sbt", dest="sbt_path",
                        help="path to the 'swift-build-tool' tool "
                             "[%(default)s]",
                        metavar="PATH")
    parser.add_argument("--sysroot",
                        help="compiler sysroot to pass to Swift [%(default)s]",
                        default=g_default_sysroot, metavar="PATH")
    parser.add_argument("--build", dest="build_path",
                        help="create build products at PATH [%(default)s]",
                        default=".build", metavar="PATH")
    parser.add_argument("--prefix", dest="install_prefix",
                        help="use PATH as the prefix for installing "
                             "[%(default)s]",
                        default="/usr/local", metavar="PATH")
    parser.add_argument("-v", "--verbose", action="store_true",
                        help="use verbose output")
    parser.add_argument("--foundation", dest="foundation_path",
                        help="Path to Foundation build directory")
    parser.add_argument("--xctest", dest="xctest_path",
                        help="Path to XCTest build directory")
    parser.add_argument("--libdispatch-build-dir", dest="libdispatch_build_dir",
                        help="Path to the libdispatch build directory")
    parser.add_argument("--libdispatch-source-dir", dest="libdispatch_source_dir",
                        help="Path to the libdispatch source directory")
    parser.add_argument("--release", action="store_true",
                        help="Build stage 2 for release")
    parser.add_argument("--generate-xcodeproj", action="store_true",
                        help="Also generate an Xcode project for SwiftPM")
    parser.add_argument("--vendor-name", dest="vendor_name",
                        help="vendor name for use in --version")
    parser.add_argument("--build-identifier", dest="build_identifier",
                        help="build identifier for use in --version")
    args = parser.parse_args()

    if not args.swiftc_path:
        args.swiftc_path = get_swiftc_path()

    # Absolutize input paths.
    if args.build_path:
        args.build_path = os.path.abspath(args.build_path)
    if args.swiftc_path:
        args.swiftc_path = os.path.abspath(args.swiftc_path)
    if args.sbt_path:
        args.sbt_path = os.path.abspath(args.sbt_path)
    if args.foundation_path:
        args.foundation_path = os.path.abspath(args.foundation_path)
    if args.xctest_path:
        args.xctest_path = os.path.abspath(args.xctest_path)
        
    build_actions = set(args.build_actions)
            
    # Validate the build actions.
    for action in build_actions:
        if action not in ("clean", "all", "test", "install"):
            raise SystemExit("unknown build action: %r" % (action,))

    # Compute the build paths.
    build_path = os.path.join(g_project_root, args.build_path)
    sandbox_path = os.path.join(build_path, ".bootstrap")

    # If the action is "clean", just remove the bootstrap and build directories.
    if "clean" in build_actions:
        cmd = ["rm", "-rf", sandbox_path]
        note("cleaning stage1: %s" % (' '.join(cmd),))
        result = subprocess.call(cmd)
        if result != 0:
            error("build failed with exit status %d" % (result,))

        cmd = ["rm", "-rf", build_path]
        note("cleaning self-hosted: %s" % (' '.join(cmd),))
        result = subprocess.call(cmd)
        if result != 0:
            error("build failed with exit status %d" % (result,))
        raise SystemExit(0)

    # All other actions build.

    # Create the sandbox.
    mkdir_p(sandbox_path)

    # Determine the swift-build-tool to use.
    args.sbt_path = os.path.abspath(
        args.sbt_path or get_swift_build_tool_path())

    # Create or update the bootstrap files.
    create_bootstrap_files(sandbox_path, args)

    # Run the stage1 build.
    cmd = [args.sbt_path, "-f", os.path.join(sandbox_path, "build.swift-build")]
    if args.verbose:
        cmd.append("-v")
    note("building stage1: %s" % ' '.join(cmd))
    result = subprocess.call(cmd)
    if result != 0:
        error("build failed with exit status %d" % (result,))

    # Stage the stage1 runtime library.
    #
    # FIXME: Integrate this into the bootstrap build.
    runtime_module_path, runtime_lib_path = process_runtime_libraries(
        sandbox_path, args, bootstrap=True)

    libdir = os.path.join(build_path, "lib")
    bindir = os.path.join(build_path, "debug")
    mkdir_p(bindir)
    bootstrapped_product = os.path.join(bindir, "swift-build-stage1")

    # Construct a fake toolchain so swift-build can build itself
    # without requiring it to have hacky-edge-case logic
    def make_fake_toolchain():
        symlink_force(args.swiftc_path, os.path.join(bindir, "swiftc"))
        symlink_force(args.sbt_path, os.path.join(bindir, "swift-build-tool"))
        symlink_force(os.path.join(sandbox_path, "bin", "swift-build"),
                      bootstrapped_product)
        if os.path.isdir(libdir) and not os.path.islink(libdir):
            # TODO remove, here to prevent revlock incremental CI build failures
            shutil.rmtree(libdir)
        symlink_force(os.path.join(sandbox_path, "lib"), build_path)
        if args.foundation_path:
            libswiftdir = os.path.join(sandbox_path, "lib", "swift", "linux")
            mkdir_p(libswiftdir)
            symlink_force(os.path.join(args.foundation_path, 'libFoundation.so'),
                libswiftdir)
            if args.libdispatch_build_dir:
                symlink_force(os.path.join(args.libdispatch_build_dir, "src", ".libs", "libdispatch.so"),
                    libswiftdir)

    make_fake_toolchain()

    # Build the package manager with itself.

    # Compute the build flags, needed for swift-build and swift-test.
    build_flags = []
    
    # We need to embed an RPATH so swift-{build,test} can find the core
    # libraries.
    if platform.system() == 'Linux':
        embed_rpath = "$ORIGIN/../lib/swift/linux"
    else:
        embed_rpath = "@executable_path/../lib/swift/macosx"
    build_flags.extend(["-Xlinker", "-rpath", "-Xlinker", embed_rpath])
    if args.verbose:
        build_flags.append("-v")

    # If appropriate, add flags for a custom version string:
    if args.vendor_name or args.build_identifier:
        incdir = os.path.join(sandbox_path, "inc")
        build_flags.extend(["-Xswiftc", "-I{}".format(incdir)])
        build_flags.extend(["-Xswiftc", "-DHasCustomVersionString"])
    
    if args.foundation_path:
        core_foundation_path = os.path.join(
            args.foundation_path, "usr", "lib", "swift")
        # Tell the linker where to look for XCTest, but autolinking
        # knows to pass -lXCTest.
        build_flags.extend(["-Xlinker", "-L", "-Xlinker", args.foundation_path])
        # Add an RPATH, so that the tests can be run directly.
        build_flags.extend(["-Xlinker", "-rpath", "-Xlinker",
                            args.foundation_path])
        build_flags.extend(["-Xswiftc", "-I{}".format(args.foundation_path)])
        build_flags.extend(["-Xswiftc", "-I{}".format(core_foundation_path)])

    if args.xctest_path:
        # Tell the linker where to look for XCTest, but autolinking
        # knows to pass -lXCTest.
        build_flags.extend(["-Xlinker", "-L", "-Xlinker", args.xctest_path])
        # Add an RPATH, so that the tests can be run directly.
        build_flags.extend(["-Xlinker", "-rpath", "-Xlinker", args.xctest_path])
        build_flags.extend(["-Xswiftc", "-I{}".format(args.xctest_path)])

    if args.libdispatch_build_dir:
        build_flags.extend(["-Xlinker", "-L{}".format(
            os.path.join(args.libdispatch_build_dir, "src", ".libs"))])
        build_flags.extend(["-Xswiftc", "-I{}".format(
            os.path.join(args.libdispatch_build_dir, "src"))])
        build_flags.extend(["-Xswiftc", "-I{}".format(
            os.path.join(args.libdispatch_build_dir, "src", "swift"))])
        build_flags.extend(["-Xswiftc", "-I{}".format(
            args.libdispatch_source_dir)])
        build_flags.extend(["-Xcc", "-fblocks"])
    
    env_cmd = ["env", "SWIFT_EXEC=" + os.path.join(bindir, "swiftc"),
                      "SWIFT_BUILD_PATH=" + build_path]
    if args.sysroot:
        env_cmd.append("SYSROOT=" + args.sysroot)
    cmd = env_cmd + [bootstrapped_product] + build_flags

    if args.release:
        cmd.extend(["--configuration", "release"])

    # Always build tests in stage2, unless building for release.
    #
    # FIXME: Resolve how we are going to deal with @testable and release builds.
    if not args.release:
        cmd.extend(["--build-tests"])

    note("building self-hosted 'swift-build': %s" % (
        ' '.join(cmd),))
    result = subprocess.call(cmd, cwd=g_project_root)
    if result != 0:
        error("build failed with exit status %d" % (result,))

    if args.release:
        conf = "release"
    else:
        conf = "debug"

    swift_package_path = os.path.join(build_path, conf, "swift-package")
    swift_build_path = os.path.join(build_path, conf, "swift-build")
    swift_test_path = os.path.join(build_path, conf, "swift-test")
    swiftpm_xctest_helper_path = os.path.join(
        build_path, conf, "swiftpm-xctest-helper")

    # If testing, run each of the test bundles.
    if "test" in build_actions:
        # Construct the test environment.
        cmd = env_cmd + [swift_test_path] + build_flags
        result = subprocess.call(cmd, cwd=g_project_root)
        if result != 0:
            error("tests failed with exit status %d" % (result,))

    # If installing, put the build products in the appropriate location.
    if "install" in build_actions:
        bin_install_path = os.path.join(g_project_root, args.install_prefix,
                                        "bin")
        lib_install_path = os.path.join(g_project_root, args.install_prefix,
                                        "lib", "swift", "pm")
        libexec_install_path = os.path.join(g_project_root, args.install_prefix,
                                        "libexec", "swift", "pm")
        mkdir_p(bin_install_path)
        mkdir_p(lib_install_path)
        mkdir_p(libexec_install_path)

        # Install a binary file at the install path.
        def installBinary(binary_path, install_path, add_rpath=None):
            cmd = ["install", binary_path, install_path]
            note("installing %s: %s" % (
                os.path.basename(binary_path), ' '.join(cmd)))
            result = subprocess.call(cmd)
            if result != 0:
                error("install failed with exit status %d" % (result,))
                
            # Remove the hard-coded stdlib RPATHs that `swiftc` bakes in on
            # Darwin.
            #
            # FIXME: We need a way to control this, instead of having to rip it
            # out after the fact. https://bugs.swift.org/browse/SR-1967
            if platform.system() == 'Darwin':
                installed_path = os.path.join(
                    install_path, os.path.basename(binary_path))
                stdlib_path = os.path.realpath(
                    os.path.join(os.path.dirname(args.swiftc_path), "..",
                                 "lib", "swift", "macosx"))
                cmd = ["install_name_tool", "-delete_rpath",
                       stdlib_path, installed_path]
                note("removing stray RPATH from %s: %s" % (
                        installed_path, ' '.join(cmd)))
                result = subprocess.call(cmd)
                if result != 0:
                    error("command  failed with exit status %d" % (result,))

                # Add an additional RPATH, if requested.
                if add_rpath:
                    cmd = ["install_name_tool", "-add_rpath",
                           add_rpath, installed_path]
                    note("adding RPATH to %s: %s" % (
                            installed_path, ' '.join(cmd)))
                    result = subprocess.call(cmd)
                    if result != 0:
                        error("command  failed with exit status %d" % (result,))
            else:
                if add_rpath:
                    error("unable to add RPATHs on this platform")

        # Install XCTest helper inside libexec.
        if platform.system() == 'Darwin':
            # Append the required RPATH for finding the standard libraries from
            # the libexec install path.
            #
            # FIXME: We need to find a way to express this from within the
            # package manager. https://bugs.swift.org/browse/SR-1968
            installBinary(swiftpm_xctest_helper_path, libexec_install_path,
                          add_rpath=("@executable_path/../../../"
                                     "lib/swift/macosx"))

        for product_path in [swift_package_path, swift_build_path,
                             swift_test_path]:
            installBinary(product_path, bin_install_path)

        # Install the PackageDescription runtime library.
        installBinary(runtime_lib_path, lib_install_path)

        # Install the PackageDescription module.
        cmd = ["install", "-m", "0644",
               runtime_module_path, lib_install_path]
        note("installing %s: %s" % (
            os.path.basename(runtime_module_path), ' '.join(cmd)))
        result = subprocess.call(cmd)
        if result != 0:
            error("install failed with exit status %d" % (result,))
                
    # If generating an Xcode project, also use the build product to do that.
    if args.generate_xcodeproj:
        # We will use the `swift-package` binary we just built to generate the
        # Xcode project.
        cmd = [swift_package_path, "generate-xcodeproj"]
        
        # If there is a `llvm-profdata` binary next to `swiftc`, we enable code
        # coverage in the generated project.
        llvm_profdata_path = os.path.join(os.path.dirname(args.swiftc_path),
            "llvm-profdata")
        if os.path.exists(llvm_profdata_path):
            cmd.append("--enable-code-coverage")

        # If a TOOLCHAINS value is active, embed it in the project.
        toolchains = os.getenv("TOOLCHAINS")
        if toolchains is not None:
            xcconfig_path = os.path.join("SwiftPM.xcodeproj/overrides.xcconfig")
            cmd += ["--xcconfig-overrides", xcconfig_path]
            
        # Call `swift-package` to generate the Xcode project.
        note("generating Xcode project: %s" % (' '.join(cmd),))
        result = subprocess.call(cmd)
        if result != 0:
            error("xcodeproj generation failed with exit status %d" % (result,))

        # Generate the .xcconfig file.
        if toolchains is not None:
            with open(xcconfig_path, "w") as f:
                print("TOOLCHAINS = %s" % (toolchains,), file=f)
                
        # Pretty hacky: insert SWIFT_EXEC into the scheme. We may want to
        # add an option to the `generate-xcodeproj` subcommand to allow a
        # user to specify env variable/value pairs to generate into the
        # scheme, but that seems a bit too arbitrary at this point.
        cmd = ["sed", "-i", "",
            "-e", "s|shouldUseLaunchSchemeArgsEnv = \"YES\"|"
                    "shouldUseLaunchSchemeArgsEnv = \"NO\"|",
            "-e", "s|</TestAction>|"
                    "<EnvironmentVariables>"
                      "<EnvironmentVariable"
                        " key=" + make_xml_string_literal("SWIFT_EXEC") +
                        " value=" + make_xml_string_literal(args.swiftc_path) +
                        " isEnabled=\"YES\">"
                      "</EnvironmentVariable>"
                    "</EnvironmentVariables>&|",
            "SwiftPM.xcodeproj/xcshareddata/xcschemes/SwiftPM.xcscheme"]
        subprocess.call(cmd)
        # sed(1) doesn't tell us if it can't do the subsitution, so we check
        cmd = ["fgrep", "-q", "SWIFT_EXEC",
            "SwiftPM.xcodeproj/xcshareddata/xcschemes/SwiftPM.xcscheme"]
        result = subprocess.call(cmd)
        if result != 0:
            error("xcscheme modification failed; couldn't set SWIFT_EXEC")

if __name__ == '__main__':
    main()
